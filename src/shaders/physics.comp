#version 450

// Optimized workgroup size for maximum GPU occupancy
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Push constants for timing and control
layout(push_constant) uniform PhysicsPushConstants {
    float time;
    float deltaTime;
    uint entityCount;
    uint frame;
    uint entityOffset;  // For chunked dispatches
} pc;

// Unified SoA binding layout (shared with movement shader)
layout(std430, binding = 0) buffer VelocityBuffer {
    vec4 velocities[];  // R/W: velocity.xy, damping, reserved
} velocityBuffer;

layout(std430, binding = 1) buffer MovementParamsBuffer {
    vec4 movementParams[];  // Shared layout; unused in this shader
} movementParamsBuffer;

layout(std430, binding = 2) buffer RuntimeStateBuffer {
    vec4 runtimeStates[];  // R/W: totalTime, reserved, stateTimer, initialized
} runtimeStateBuffer;

layout(std430, binding = 6) buffer ModelMatrixBuffer {
    mat4 modelMatrices[];
} modelMatrixBuffer;

layout(std430, binding = 8) buffer ControlParamsBuffer {
    vec4 controlParams[];  // desiredVel.xy, controlFlag, renderScale
} controlParamsBuffer;

// Physics-specific buffers
layout(std430, binding = 3) buffer PositionBuffer {
    vec4 positions[]; // RW: computed positions for graphics
} outPositions;

layout(std430, binding = 4) buffer CurrentPositionBuffer {
    vec4 currentPositions[]; // R/W: physics integration state
} currentPos;

// Spatial map buffer for collision detection and spatial queries
layout(std430, binding = 7) buffer SpatialMapBuffer {
    uvec2 spatialCells[]; // R/W: spatial hash grid - packed (head, unused)
} spatialMap;

layout(std430, binding = 9) buffer SpatialNextBuffer {
    uint nextIndices[]; // R/W: per-entity next index for linked list
} spatialNextBuffer;

/* ---------- Spatial Map Constants and Functions ---------- */

// Spatial grid configuration
const float CELL_SIZE = 1.5;           // Size of each spatial cell
const uint GRID_WIDTH = 64;            // Grid dimensions (must be power of 2)
const uint GRID_HEIGHT = 64;
const uint SPATIAL_MAP_SIZE = GRID_WIDTH * GRID_HEIGHT; // 4096 cells
const uint NULL_INDEX = 0xFFFFFFFF;    // Null pointer for linked list

// Fast spatial hash function using bit mixing
uint spatialHash(vec2 position) {
    // Convert world position to grid coordinates
    ivec2 gridCoord = ivec2(floor(position / CELL_SIZE));
    
    // Wrap to grid bounds using bitwise AND (requires power-of-2 dimensions)
    uint x = uint(gridCoord.x) & (GRID_WIDTH - 1);
    uint y = uint(gridCoord.y) & (GRID_HEIGHT - 1);
    
    // Simple hash: x + y * width
    return x + y * GRID_WIDTH;
}

// Update spatial map entry for this entity
void updateSpatialMap(uint entityIndex, vec2 position) {
    uint cellIndex = spatialHash(position);
    
    // Atomic compare-swap loop to safely update the linked list head
    uint expectedHead;
    do {
        expectedHead = spatialMap.spatialCells[cellIndex].x;
    } while (atomicCompSwap(spatialMap.spatialCells[cellIndex].x, expectedHead, entityIndex) != expectedHead);
    
    // Store old head as our next pointer (building linked list)
    spatialNextBuffer.nextIndices[entityIndex] = expectedHead;
}

/* ---------- Collision Detection Constants and Functions ---------- */

// Collision detection configuration
const uint MAX_ENTITIES_PER_CELL = 64;    // Maximum entities to check per cell (much higher)
const float TRIANGLE_RADIUS = 2.8284271;  // Bounding circle radius for triangle mesh
const float MIN_SEPARATION = 0.0;         // Additional gap between entities
const float RESTITUTION = 0.35;           // 0 = inelastic, 1 = elastic
const float FRICTION = 0.2;               // Tangential friction
const float COLLISION_EPS = 0.001;        // Small separation gap to prevent overlap

// Triangle vertices relative to entity center
const vec2 TRIANGLE_VERTICES[3] = vec2[](
    vec2(0.0, 0.5),      // Top vertex
    vec2(-0.4, -0.25),   // Bottom left
    vec2(0.4, -0.25)     // Bottom right
);

// Fast entity collection using spatial map (optimized)
uint collectEntitiesInCell(uint cellIndex, out uint entities[MAX_ENTITIES_PER_CELL]) {
    uint count = 0;
    
    // Read head entity from spatial map
    uint headEntity = spatialMap.spatialCells[cellIndex].x;
    uint current = headEntity;
    while (current != NULL_INDEX && current < pc.entityCount && count < MAX_ENTITIES_PER_CELL) {
        entities[count++] = current;
        current = spatialNextBuffer.nextIndices[current];
    }
    
    return count;
}

// Circle-circle collision test for quick culling
bool circleCollision(vec2 pos1, vec2 pos2, float radius1, float radius2) {
    float distSq = dot(pos2 - pos1, pos2 - pos1);
    float radiusSum = radius1 + radius2;
    return distSq < (radiusSum * radiusSum);
}

// Point-in-triangle test using barycentric coordinates
bool pointInTriangle(vec2 p, vec2 a, vec2 b, vec2 c) {
    vec2 v0 = c - a;
    vec2 v1 = b - a;
    vec2 v2 = p - a;
    
    float dot00 = dot(v0, v0);
    float dot01 = dot(v0, v1);
    float dot02 = dot(v0, v2);
    float dot11 = dot(v1, v1);
    float dot12 = dot(v1, v2);
    
    float invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);
    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    
    return (u >= 0.0) && (v >= 0.0) && (u + v <= 1.0);
}

// Triangle-triangle intersection test
bool triangleTriangleCollision(vec2 pos1, vec2 pos2) {
    // Get triangle vertices in world space
    vec2 tri1[3];
    vec2 tri2[3];
    
    for (int i = 0; i < 3; i++) {
        tri1[i] = pos1 + TRIANGLE_VERTICES[i];
        tri2[i] = pos2 + TRIANGLE_VERTICES[i];
    }
    
    // Check if any vertex of tri1 is inside tri2
    for (int i = 0; i < 3; i++) {
        if (pointInTriangle(tri1[i], tri2[0], tri2[1], tri2[2])) {
            return true;
        }
    }
    
    // Check if any vertex of tri2 is inside tri1
    for (int i = 0; i < 3; i++) {
        if (pointInTriangle(tri2[i], tri1[0], tri1[1], tri1[2])) {
            return true;
        }
    }
    
    return false;
}

// Resolve collision with strong separation force
vec2 resolveCollision(vec2 currentPos, vec2 newPos, vec2 otherPos) {
    vec2 toOther = otherPos - currentPos;
    float distToOther = length(toOther);
    
    // Calculate safe distance (sum of bounding radii + separation)
    float safeDistance = TRIANGLE_RADIUS * 2.0 + MIN_SEPARATION;
    
    if (distToOther < safeDistance) {
        // Force strong separation - push entity away from collision
        vec2 separationDirection = normalize(currentPos - otherPos);
        
        // If entities are exactly on top of each other, use random direction
        if (length(separationDirection) < 0.001) {
            separationDirection = vec2(1.0, 0.0); // Default direction
        }
        
        // Position entity at safe distance away from other entity
        vec2 safePos = otherPos + separationDirection * safeDistance;
        return safePos;
    }
    
    return newPos; // No collision resolution needed
}

void main() {
    // Clear spatial cells (each thread clears one cell)
    if (gl_GlobalInvocationID.x < SPATIAL_MAP_SIZE) {
        spatialMap.spatialCells[gl_GlobalInvocationID.x] = uvec2(NULL_INDEX, 0);
    }
    barrier();
    memoryBarrierShared();
    
    // Get current entity index with chunk offset
    uint entityIndex = gl_GlobalInvocationID.x + pc.entityOffset;
    
    // Early exit for out-of-bounds entities
    if (entityIndex >= pc.entityCount) {
        return;
    }
    
    // Load entity data from SoA buffers - better cache locality
    vec4 velocity = velocityBuffer.velocities[entityIndex];
    vec4 runtimeState = runtimeStateBuffer.runtimeStates[entityIndex];
    float initialized = runtimeState.w; // initialized flag is in .w
    
    // Extract velocity and damping
    vec2 vel = velocity.xy;
    float damping = velocity.z;
    
    // Player override: controlParams.z marks manual control; xy holds desired velocity
    vec4 control = controlParamsBuffer.controlParams[entityIndex];
    if (control.z > 0.5) {
        vel = control.xy;
        damping = 1.0;
    }
    
    // SIMPLIFIED: Read position directly from output buffer, integrate velocity
    vec3 currentPosition = outPositions.positions[entityIndex].xyz;
    
    // On first frame, initialize position if it's zero
    if (length(currentPosition) < 0.01) {
        // Use spawn position from entity index (simple grid)
        currentPosition = vec3(
            float(entityIndex % 10) * 0.8 - 4.0,
            float(entityIndex / 10) * 0.8 - 4.0, 
            0.0
        );
    }
    
    // Physics integration: position += velocity * deltaTime (only if velocity is non-zero)
    if (length(vel) > 0.01) {
        // Enhanced physics integration for frequent movement updates
        currentPosition.x += vel.x * pc.deltaTime * 15.0;
        currentPosition.y += vel.y * pc.deltaTime * 15.0;
    }
    
    // Moderate damping to balance frequent updates with momentum retention
    vel *= 0.998;
    
    // Write tentative position to current buffer first
    currentPos.currentPositions[entityIndex] = vec4(currentPosition, 1.0);
    
    // Update spatial map with new position
    updateSpatialMap(entityIndex, currentPosition.xy);
    
    // Wait for all threads to update their positions and spatial maps
    barrier();
    memoryBarrierShared();
    
    // Spatial hash collision detection - much faster than O(NÂ²)
    vec2 resolvedPosition = currentPosition.xy;
    
    // Pre-calculate collision parameters (per-entity override via runtimeState.y)
    vec4 selfControl = controlParamsBuffer.controlParams[entityIndex];
    float baseSelfRadius = runtimeState.y > 0.0 ? runtimeState.y : TRIANGLE_RADIUS;
    vec3 selfScale = vec3(
        length(modelMatrixBuffer.modelMatrices[entityIndex][0].xyz),
        length(modelMatrixBuffer.modelMatrices[entityIndex][1].xyz),
        length(modelMatrixBuffer.modelMatrices[entityIndex][2].xyz)
    );
    float selfRadius = baseSelfRadius * max(selfScale.x, selfScale.y);
    
    // Get our spatial cell
    uint cellIndex = spatialHash(currentPosition.xy);
    
    // Check all 8 neighboring cells plus current cell (3x3 grid)
    const int offsets[9][2] = int[9][2](
        int[2](0, 0),   // Current cell
        int[2](-1, 0),  // Left
        int[2](1, 0),   // Right  
        int[2](0, -1),  // Up
        int[2](0, 1),   // Down
        int[2](-1, -1), // Top-left diagonal
        int[2](1, -1),  // Top-right diagonal
        int[2](-1, 1),  // Bottom-left diagonal
        int[2](1, 1)    // Bottom-right diagonal
    );
    
    for (int cellIdx = 0; cellIdx < 9; cellIdx++) {
        int dx = offsets[cellIdx][0];
        int dy = offsets[cellIdx][1];
        
        // Calculate neighbor cell coordinates
        int cellX = int(cellIndex % GRID_WIDTH) + dx;
        int cellY = int(cellIndex / GRID_WIDTH) + dy;
        
        // Wrap around grid boundaries
        cellX = ((cellX % int(GRID_WIDTH)) + int(GRID_WIDTH)) % int(GRID_WIDTH);
        cellY = ((cellY % int(GRID_HEIGHT)) + int(GRID_HEIGHT)) % int(GRID_HEIGHT);
        uint neighborCell = uint(cellX + cellY * int(GRID_WIDTH));
        
        // Collect entities in this neighboring cell
        uint entitiesInCell[MAX_ENTITIES_PER_CELL];
        uint entityCount = collectEntitiesInCell(neighborCell, entitiesInCell);
        
        // Check collision with entities in this cell
        for (uint i = 0; i < entityCount; i++) {
            uint otherEntityIndex = entitiesInCell[i];
            if (otherEntityIndex == entityIndex) continue; // Skip self
            if (otherEntityIndex >= pc.entityCount) continue;
            
            // Get other entity's position
            vec3 otherPos = currentPos.currentPositions[otherEntityIndex].xyz;
            
            // Fast squared distance check (no expensive sqrt)
            vec2 diff = resolvedPosition - otherPos.xy;
            float distSq = dot(diff, diff);

            // Cheap upper-bound rejection to avoid extra buffer reads
            float maxRadius = selfRadius + TRIANGLE_RADIUS + MIN_SEPARATION;
            if (distSq >= (maxRadius * maxRadius)) {
                continue;
            }

            vec4 otherRuntimeState = runtimeStateBuffer.runtimeStates[otherEntityIndex];
            float baseOtherRadius = otherRuntimeState.y > 0.0 ? otherRuntimeState.y : TRIANGLE_RADIUS;
            vec3 otherScale = vec3(
                length(modelMatrixBuffer.modelMatrices[otherEntityIndex][0].xyz),
                length(modelMatrixBuffer.modelMatrices[otherEntityIndex][1].xyz),
                length(modelMatrixBuffer.modelMatrices[otherEntityIndex][2].xyz)
            );
            float otherRadius = baseOtherRadius * max(otherScale.x, otherScale.y);
            float collisionRadius = selfRadius + otherRadius + MIN_SEPARATION;
            float collisionRadiusSq = collisionRadius * collisionRadius;

            if (distSq < collisionRadiusSq) {
                vec2 separationDir;
                float dist;
                if (distSq < 0.000001) {
                    separationDir = vec2(1.0, 0.0);
                    dist = 0.0;
                } else {
                    float invDist = inversesqrt(distSq);
                    separationDir = diff * invDist;
                    dist = distSq * invDist;
                }

                float penetration = collisionRadius - dist;
                if (penetration > 0.0) {
                    resolvedPosition += separationDir * (penetration * 0.5 + COLLISION_EPS);
                }

                // Sequential impulse response (unit masses)
                vec2 otherVel = velocityBuffer.velocities[otherEntityIndex].xy;
                vec2 relVel = vel - otherVel;
                float velAlongNormal = dot(relVel, separationDir);
                if (velAlongNormal < 0.0) {
                    float j = -(1.0 + RESTITUTION) * velAlongNormal * 0.5;
                    vel += j * separationDir;

                    vec2 tangent = relVel - velAlongNormal * separationDir;
                    float tangentLen = length(tangent);
                    if (tangentLen > 0.0001) {
                        vec2 tangentDir = tangent / tangentLen;
                        float jt = -dot(relVel, tangentDir) * 0.5;
                        float maxFriction = FRICTION * j;
                        jt = clamp(jt, -maxFriction, maxFriction);
                        vel += jt * tangentDir;
                    }
                }
            }
        }
    }
    
    // Write back final velocity and resolved position
    velocityBuffer.velocities[entityIndex].xy = vel;
    outPositions.positions[entityIndex] = vec4(resolvedPosition, currentPosition.z, 1.0);
}
