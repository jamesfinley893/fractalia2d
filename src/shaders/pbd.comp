#version 450

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform PBDPushConstants {
    float time;
    float deltaTime;
    uint bodyCount;
    uint particleCount;
    uint constraintCount;
    uint frame;
    uint elementOffset;
    uint mode;
} pc;

layout(std430, binding = 0) buffer VelocityBuffer {
    vec4 velocities[];
} velocityBuffer;

layout(std430, binding = 1) buffer MovementParamsBuffer {
    vec4 movementParams[];
} movementParamsBuffer;

layout(std430, binding = 2) buffer RuntimeStateBuffer {
    vec4 runtimeStates[];
} runtimeStateBuffer;

layout(std430, binding = 3) buffer PositionBuffer {
    vec4 positions[];
} positionBuffer;

layout(std430, binding = 4) buffer CurrentPositionBuffer {
    vec4 currentPositions[];
} currentPositionBuffer;

layout(std430, binding = 7) buffer SpatialMapBuffer {
    uvec2 spatialCells[];
} spatialMapBuffer;

layout(std430, binding = 8) buffer ControlParamsBuffer {
    vec4 controlParams[];
} controlParamsBuffer;

layout(std430, binding = 9) buffer SpatialNextBuffer {
    uint nextIndices[];
} spatialNextBuffer;

layout(std430, binding = 10) buffer ParticleVelocityBuffer {
    vec4 particleVelocities[];
} particleVelocityBuffer;

layout(std430, binding = 11) buffer ParticleInvMassBuffer {
    float invMasses[];
} particleInvMassBuffer;

layout(std430, binding = 12) buffer ParticleBodyBuffer {
    uint particleBodies[];
} particleBodyBuffer;

layout(std430, binding = 13) buffer BodyDataBuffer {
    uvec4 bodyData[];
} bodyDataBuffer;

layout(std430, binding = 14) buffer BodyParamsBuffer {
    vec4 bodyParams[];
} bodyParamsBuffer;

struct DistanceConstraint {
    uint a;
    uint b;
    float restLength;
    float stiffness;
};

layout(std430, binding = 15) buffer DistanceConstraintBuffer {
    DistanceConstraint constraints[];
} distanceConstraintBuffer;

const uint MODE_INTEGRATE = 0u;
const uint MODE_CLEAR_SPATIAL = 1u;
const uint MODE_BUILD_SPATIAL = 2u;
const uint MODE_SOLVE_DISTANCE = 3u;
const uint MODE_SOLVE_AREA = 4u;
const uint MODE_COLLIDE = 5u;
const uint MODE_FINALIZE = 6u;

const float CELL_SIZE = 1.5;
const uint GRID_WIDTH = 64;
const uint GRID_HEIGHT = 64;
const uint SPATIAL_MAP_SIZE = GRID_WIDTH * GRID_HEIGHT;
const uint NULL_INDEX = 0xFFFFFFFFu;
const uint MAX_ENTITIES_PER_CELL = 64;
const float COLLISION_EPS = 0.0005;

uint spatialHash(vec2 position) {
    ivec2 gridCoord = ivec2(floor(position / CELL_SIZE));
    uint x = uint(gridCoord.x) & (GRID_WIDTH - 1);
    uint y = uint(gridCoord.y) & (GRID_HEIGHT - 1);
    return x + y * GRID_WIDTH;
}

void clearSpatial(uint cellIndex) {
    spatialMapBuffer.spatialCells[cellIndex] = uvec2(NULL_INDEX, 0);
}

void buildSpatial(uint particleIndex) {
    vec2 pos = positionBuffer.positions[particleIndex].xy;
    uint cellIndex = spatialHash(pos);
    uint expectedHead;
    do {
        expectedHead = spatialMapBuffer.spatialCells[cellIndex].x;
    } while (atomicCompSwap(spatialMapBuffer.spatialCells[cellIndex].x, expectedHead, particleIndex) != expectedHead);
    spatialNextBuffer.nextIndices[particleIndex] = expectedHead;
}

void integrate(uint particleIndex) {
    uint bodyIndex = particleBodyBuffer.particleBodies[particleIndex];
    if (bodyIndex >= pc.bodyCount) {
        return;
    }

    vec2 pos = positionBuffer.positions[particleIndex].xy;
    vec2 vel = particleVelocityBuffer.particleVelocities[particleIndex].xy;

    vec2 drive = velocityBuffer.velocities[bodyIndex].xy;
    vec4 control = controlParamsBuffer.controlParams[bodyIndex];
    if (control.z > 0.5) {
        drive = control.xy;
    }

    vel = mix(vel, drive, 0.15);
    pos += vel * pc.deltaTime;

    positionBuffer.positions[particleIndex] = vec4(pos, 0.0, 1.0);
    particleVelocityBuffer.particleVelocities[particleIndex] = vec4(vel, 0.0, 0.0);
}

void solveDistance(uint constraintIndex) {
    DistanceConstraint c = distanceConstraintBuffer.constraints[constraintIndex];
    if (c.a >= pc.particleCount || c.b >= pc.particleCount) {
        return;
    }

    vec2 p1 = positionBuffer.positions[c.a].xy;
    vec2 p2 = positionBuffer.positions[c.b].xy;

    float w1 = particleInvMassBuffer.invMasses[c.a];
    float w2 = particleInvMassBuffer.invMasses[c.b];
    float wSum = w1 + w2;
    if (wSum <= 0.0) {
        return;
    }

    vec2 delta = p1 - p2;
    float distSq = dot(delta, delta);
    if (distSq < 1e-8) {
        return;
    }
    float dist = sqrt(distSq);
    float cVal = dist - c.restLength;
    vec2 n = delta / dist;
    vec2 correction = -cVal / wSum * n * c.stiffness;

    p1 += correction * w1;
    p2 -= correction * w2;

    positionBuffer.positions[c.a].xy = p1;
    positionBuffer.positions[c.b].xy = p2;
}

void solveArea(uint bodyIndex) {
    if (bodyIndex >= pc.bodyCount) {
        return;
    }

    uvec4 data = bodyDataBuffer.bodyData[bodyIndex];
    uint offset = data.x;
    if (offset + 2u >= pc.particleCount) {
        return;
    }

    vec2 p0 = positionBuffer.positions[offset + 0u].xy;
    vec2 p1 = positionBuffer.positions[offset + 1u].xy;
    vec2 p2 = positionBuffer.positions[offset + 2u].xy;

    float area = 0.5 * ((p1.x - p0.x) * (p2.y - p0.y) - (p1.y - p0.y) * (p2.x - p0.x));
    float restArea = bodyParamsBuffer.bodyParams[bodyIndex].w;
    float signedRestArea = area < 0.0 ? -restArea : restArea;
    float cVal = area - signedRestArea;

    vec2 grad0 = 0.5 * vec2(p1.y - p2.y, p2.x - p1.x);
    vec2 grad1 = 0.5 * vec2(p2.y - p0.y, p0.x - p2.x);
    vec2 grad2 = 0.5 * vec2(p0.y - p1.y, p1.x - p0.x);

    float w0 = particleInvMassBuffer.invMasses[offset + 0u];
    float w1 = particleInvMassBuffer.invMasses[offset + 1u];
    float w2 = particleInvMassBuffer.invMasses[offset + 2u];

    float sum = w0 * dot(grad0, grad0) + w1 * dot(grad1, grad1) + w2 * dot(grad2, grad2);
    if (sum <= 1e-8) {
        return;
    }

    float stiffness = bodyParamsBuffer.bodyParams[bodyIndex].y;
    float s = -cVal / sum * stiffness;

    p0 += grad0 * (s * w0);
    p1 += grad1 * (s * w1);
    p2 += grad2 * (s * w2);

    positionBuffer.positions[offset + 0u].xy = p0;
    positionBuffer.positions[offset + 1u].xy = p1;
    positionBuffer.positions[offset + 2u].xy = p2;
}

uint collectEntitiesInCell(uint cellIndex, out uint entities[MAX_ENTITIES_PER_CELL]) {
    uint count = 0;
    uint current = spatialMapBuffer.spatialCells[cellIndex].x;
    while (current != NULL_INDEX && current < pc.particleCount && count < MAX_ENTITIES_PER_CELL) {
        entities[count++] = current;
        current = spatialNextBuffer.nextIndices[current];
    }
    return count;
}

void collide(uint particleIndex) {
    uint bodyIndex = particleBodyBuffer.particleBodies[particleIndex];
    if (bodyIndex >= pc.bodyCount) {
        return;
    }

    vec2 pos = positionBuffer.positions[particleIndex].xy;
    float restArea = bodyParamsBuffer.bodyParams[bodyIndex].w;
    float baseRadius = sqrt(max(restArea, 0.0001)) * 0.35;
    float radius = max(baseRadius, 0.1);

    uint cellIndex = spatialHash(pos);
    const int offsets[9][2] = int[9][2](
        int[2](0, 0), int[2](-1, 0), int[2](1, 0),
        int[2](0, -1), int[2](0, 1),
        int[2](-1, -1), int[2](1, -1),
        int[2](-1, 1), int[2](1, 1)
    );

    for (int cellIdx = 0; cellIdx < 9; ++cellIdx) {
        int dx = offsets[cellIdx][0];
        int dy = offsets[cellIdx][1];
        int cellX = int(cellIndex % GRID_WIDTH) + dx;
        int cellY = int(cellIndex / GRID_WIDTH) + dy;
        cellX = ((cellX % int(GRID_WIDTH)) + int(GRID_WIDTH)) % int(GRID_WIDTH);
        cellY = ((cellY % int(GRID_HEIGHT)) + int(GRID_HEIGHT)) % int(GRID_HEIGHT);
        uint neighborCell = uint(cellX + cellY * int(GRID_WIDTH));

        uint entitiesInCell[MAX_ENTITIES_PER_CELL];
        uint entityCount = collectEntitiesInCell(neighborCell, entitiesInCell);

        for (uint i = 0; i < entityCount; ++i) {
            uint other = entitiesInCell[i];
            if (other == particleIndex || other >= pc.particleCount) {
                continue;
            }
            uint otherBody = particleBodyBuffer.particleBodies[other];
            if (otherBody == bodyIndex) {
                continue;
            }

            vec2 otherPos = positionBuffer.positions[other].xy;
            vec2 diff = pos - otherPos;
            float distSq = dot(diff, diff);
            float minDist = radius * 2.0;
            if (distSq >= minDist * minDist) {
                continue;
            }

            float dist = sqrt(max(distSq, 1e-8));
            vec2 dir = distSq < 1e-8 ? vec2(1.0, 0.0) : diff / dist;
            float penetration = minDist - dist;
            pos += dir * (penetration * 0.5 + COLLISION_EPS);
        }
    }

    positionBuffer.positions[particleIndex].xy = pos;
}

void finalize(uint particleIndex) {
    uint bodyIndex = particleBodyBuffer.particleBodies[particleIndex];
    if (bodyIndex >= pc.bodyCount) {
        return;
    }

    vec3 prev = currentPositionBuffer.currentPositions[particleIndex].xyz;
    vec3 pos = positionBuffer.positions[particleIndex].xyz;
    float dt = max(pc.deltaTime, 0.0001);
    vec3 vel = (pos - prev) / dt;
    float damping = bodyParamsBuffer.bodyParams[bodyIndex].z;
    vel *= damping;

    particleVelocityBuffer.particleVelocities[particleIndex] = vec4(vel, 0.0);
    currentPositionBuffer.currentPositions[particleIndex] = vec4(pos, 1.0);
}

void main() {
    uint index = gl_GlobalInvocationID.x + pc.elementOffset;

    if (pc.mode == MODE_CLEAR_SPATIAL) {
        if (index < SPATIAL_MAP_SIZE) {
            clearSpatial(index);
        }
        return;
    }

    if (pc.mode == MODE_INTEGRATE) {
        if (index < pc.particleCount) {
            integrate(index);
        }
        return;
    }

    if (pc.mode == MODE_BUILD_SPATIAL) {
        if (index < pc.particleCount) {
            buildSpatial(index);
        }
        return;
    }

    if (pc.mode == MODE_SOLVE_DISTANCE) {
        if (index < pc.constraintCount) {
            solveDistance(index);
        }
        return;
    }

    if (pc.mode == MODE_SOLVE_AREA) {
        if (index < pc.bodyCount) {
            solveArea(index);
        }
        return;
    }

    if (pc.mode == MODE_COLLIDE) {
        if (index < pc.particleCount) {
            collide(index);
        }
        return;
    }

    if (pc.mode == MODE_FINALIZE) {
        if (index < pc.particleCount) {
            finalize(index);
        }
    }
}
