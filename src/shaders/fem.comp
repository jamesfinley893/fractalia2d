#version 450

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform FEMPushConstants {
    float time;
    float deltaTime;
    uint bodyCount;
    uint nodeCount;
    uint triangleCount;
    uint frame;
    uint elementOffset;
    uint mode;
    uint padding;
} pc;

layout(std430, binding = 0) buffer VelocityBuffer {
    vec4 velocities[];
} velocityBuffer;

layout(std430, binding = 1) buffer MovementParamsBuffer {
    vec4 movementParams[];
} movementParamsBuffer;

layout(std430, binding = 2) buffer RuntimeStateBuffer {
    vec4 runtimeStates[];
} runtimeStateBuffer;

layout(std430, binding = 3) buffer PositionBuffer {
    vec4 positions[];
} positionBuffer;

layout(std430, binding = 4) buffer CurrentPositionBuffer {
    vec4 currentPositions[];
} currentPositionBuffer;

layout(std430, binding = 7) buffer SpatialMapBuffer {
    uvec2 spatialCells[];
} spatialMapBuffer;

layout(std430, binding = 8) buffer ControlParamsBuffer {
    vec4 controlParams[];
} controlParamsBuffer;

layout(std430, binding = 9) buffer SpatialNextBuffer {
    uint nextIndices[];
} spatialNextBuffer;

layout(std430, binding = 10) buffer NodeVelocityBuffer {
    vec4 nodeVelocities[];
} nodeVelocityBuffer;

layout(std430, binding = 11) buffer NodeInvMassBuffer {
    float nodeInvMasses[];
} nodeInvMassBuffer;

layout(std430, binding = 12) buffer BodyDataBuffer {
    uvec4 bodyData[];
} bodyDataBuffer;

layout(std430, binding = 13) buffer BodyParamsBuffer {
    vec4 bodyParams[];
} bodyParamsBuffer;

layout(std430, binding = 14) buffer TriangleRestBuffer {
    vec4 triRestData[];
} triangleRestBuffer;

layout(std430, binding = 15) buffer TriangleAreaBuffer {
    float triRestArea[];
} triangleAreaBuffer;

layout(std430, binding = 16) buffer NodeForceBuffer {
    vec4 nodeForces[];
} nodeForceBuffer;

layout(std430, binding = 17) buffer NodeRestBuffer {
    vec4 restPositions[];
} nodeRestBuffer;

layout(std430, binding = 18) buffer TriangleIndexBuffer {
    uvec4 triIndices[];
} triangleIndexBuffer;

const uint NODES_PER_BODY = 9u;
const uint TRIANGLES_PER_BODY = 8u;

const uint MODE_CLEAR_FORCES = 0u;
const uint MODE_PREDICT = 1u;
const uint MODE_LOCAL = 2u;
const uint MODE_GLOBAL = 3u;
const uint MODE_CLEAR_SPATIAL = 4u;
const uint MODE_BUILD_SPATIAL = 5u;
const uint MODE_CONTACT_CONSTRAINTS = 6u;
const uint MODE_CONTACT_VELOCITY = 7u;
const uint MODE_UPDATE_VELOCITY = 8u;

const float CELL_SIZE = 3.0;
const uint GRID_WIDTH = 64;
const uint GRID_HEIGHT = 64;
const uint SPATIAL_MAP_SIZE = GRID_WIDTH * GRID_HEIGHT;
const uint NULL_INDEX = 0xFFFFFFFFu;
const uint MAX_BODIES_PER_CELL = 64;

const float GRAVITY = -4.0;
const float BAUMGARTE_BETA = 0.2;
const float CONTACT_SLOP = 0.001;

uint spatialHash(vec2 position) {
    ivec2 gridCoord = ivec2(floor(position / CELL_SIZE));
    uint x = uint(gridCoord.x) & (GRID_WIDTH - 1);
    uint y = uint(gridCoord.y) & (GRID_HEIGHT - 1);
    return x + y * GRID_WIDTH;
}

void clearSpatial(uint cellIndex) {
    spatialMapBuffer.spatialCells[cellIndex] = uvec2(NULL_INDEX, 0);
}

void buildSpatial(uint bodyIndex, vec2 center) {
    uint cellIndex = spatialHash(center);
    uint expectedHead;
    do {
        expectedHead = spatialMapBuffer.spatialCells[cellIndex].x;
    } while (atomicCompSwap(spatialMapBuffer.spatialCells[cellIndex].x, expectedHead, bodyIndex) != expectedHead);
    spatialNextBuffer.nextIndices[bodyIndex] = expectedHead;
}

void clearGoals(uint nodeIndex) {
    nodeForceBuffer.nodeForces[nodeIndex] = vec4(0.0);
}

mat2 polarRotation(mat2 F) {
    vec2 c0 = vec2(F[0][0], F[1][0]);
    vec2 c1 = vec2(F[0][1], F[1][1]);
    float c0Len = length(c0);
    if (c0Len < 1e-6) {
        return mat2(1.0);
    }
    vec2 r0 = c0 / c0Len;
    vec2 r1 = c1 - dot(r0, c1) * r0;
    float r1Len = length(r1);
    if (r1Len < 1e-6) {
        r1 = vec2(-r0.y, r0.x);
    } else {
        r1 /= r1Len;
    }
    if (r0.x * r1.y - r0.y * r1.x < 0.0) {
        r1 = -r1;
    }
    return mat2(r0, r1);
}

void computeGoals(uint triIndex) {
    if (triIndex >= pc.triangleCount) {
        return;
    }

    uint bodyIndex = triIndex / TRIANGLES_PER_BODY;
    uvec4 data = bodyDataBuffer.bodyData[bodyIndex];

    uvec4 tri = triangleIndexBuffer.triIndices[triIndex];
    uint i0 = tri.x;
    uint i1 = tri.y;
    uint i2 = tri.z;

    vec2 x0 = positionBuffer.positions[i0].xy;
    vec2 x1 = positionBuffer.positions[i1].xy;
    vec2 x2 = positionBuffer.positions[i2].xy;

    vec2 r0 = nodeRestBuffer.restPositions[i0].xy;
    vec2 r1 = nodeRestBuffer.restPositions[i1].xy;
    vec2 r2 = nodeRestBuffer.restPositions[i2].xy;

    vec2 xCm = (x0 + x1 + x2) / 3.0;
    vec2 rCm = (r0 + r1 + r2) / 3.0;

    mat2 A = mat2(0.0);
    A += outerProduct(x0 - xCm, r0 - rCm);
    A += outerProduct(x1 - xCm, r1 - rCm);
    A += outerProduct(x2 - xCm, r2 - rCm);

    mat2 R = polarRotation(A);

    vec2 g0 = xCm + R * (r0 - rCm);
    vec2 g1 = xCm + R * (r1 - rCm);
    vec2 g2 = xCm + R * (r2 - rCm);

    vec4 params = bodyParamsBuffer.bodyParams[bodyIndex];
    float stiffness = params.x;

    nodeForceBuffer.nodeForces[i0].xy += g0 * stiffness;
    nodeForceBuffer.nodeForces[i1].xy += g1 * stiffness;
    nodeForceBuffer.nodeForces[i2].xy += g2 * stiffness;
    nodeForceBuffer.nodeForces[i0].z += stiffness;
    nodeForceBuffer.nodeForces[i1].z += stiffness;
    nodeForceBuffer.nodeForces[i2].z += stiffness;
}

void predictPosition(uint nodeIndex) {
    if (nodeIndex >= pc.nodeCount) {
        return;
    }

    vec2 vel = nodeVelocityBuffer.nodeVelocities[nodeIndex].xy;
    float invMass = nodeInvMassBuffer.nodeInvMasses[nodeIndex];

    vec2 accel = vec2(0.0, GRAVITY);

    uint bodyIndex = nodeIndex / NODES_PER_BODY;
    if (bodyIndex < pc.bodyCount) {
        vec4 control = controlParamsBuffer.controlParams[bodyIndex];
        vec2 drive = velocityBuffer.velocities[bodyIndex].xy;
        if (control.z > 0.5) {
            drive = control.xy;
        }
        accel += (drive - vel) * 6.0;
    }

    vel += accel * pc.deltaTime;
    nodeVelocityBuffer.nodeVelocities[nodeIndex].xy = vel;

    vec2 pos = positionBuffer.positions[nodeIndex].xy;
    positionBuffer.positions[nodeIndex].xy = pos + vel * pc.deltaTime;
}

vec2 bodyCenter(uint bodyIndex) {
    uvec4 data = bodyDataBuffer.bodyData[bodyIndex];
    uint offset = data.x;
    uint count = data.y;
    vec2 sum = vec2(0.0);
    for (uint i = 0u; i < count; ++i) {
        sum += positionBuffer.positions[offset + i].xy;
    }
    return sum / float(max(count, 1u));
}

float bodyRadius(uint bodyIndex, vec2 center) {
    uvec4 data = bodyDataBuffer.bodyData[bodyIndex];
    uint offset = data.x;
    uint count = data.y;
    float maxDistSq = 0.0;
    for (uint i = 0u; i < count; ++i) {
        vec2 p = positionBuffer.positions[offset + i].xy;
        vec2 d = p - center;
        maxDistSq = max(maxDistSq, dot(d, d));
    }
    return sqrt(maxDistSq);
}

bool pointInTriangle(vec2 p, vec2 a, vec2 b, vec2 c) {
    vec2 v0 = c - a;
    vec2 v1 = b - a;
    vec2 v2 = p - a;
    float dot00 = dot(v0, v0);
    float dot01 = dot(v0, v1);
    float dot02 = dot(v0, v2);
    float dot11 = dot(v1, v1);
    float dot12 = dot(v1, v2);
    float invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);
    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return (u >= 0.0) && (v >= 0.0) && (u + v <= 1.0);
}

float signedDistanceToEdge(vec2 p, vec2 a, vec2 b, out vec2 normalOut) {
    vec2 edge = b - a;
    normalOut = normalize(vec2(-edge.y, edge.x));
    return dot(p - a, normalOut);
}

float cross2d(vec2 a, vec2 b) {
    return a.x * b.y - a.y * b.x;
}

bool triSAT(vec2 a0, vec2 a1, vec2 a2, vec2 b0, vec2 b1, vec2 b2, out vec2 axisOut, out float penOut) {
    vec2 candidates[6] = vec2[](
        normalize(vec2(a1.y - a0.y, a0.x - a1.x)),
        normalize(vec2(a2.y - a1.y, a1.x - a2.x)),
        normalize(vec2(a0.y - a2.y, a2.x - a0.x)),
        normalize(vec2(b1.y - b0.y, b0.x - b1.x)),
        normalize(vec2(b2.y - b1.y, b1.x - b2.x)),
        normalize(vec2(b0.y - b2.y, b2.x - b0.x))
    );

    float minPen = 1e9;
    vec2 bestAxis = vec2(0.0);
    for (int i = 0; i < 6; ++i) {
        vec2 axis = candidates[i];
        float aMin = min(dot(a0, axis), min(dot(a1, axis), dot(a2, axis)));
        float aMax = max(dot(a0, axis), max(dot(a1, axis), dot(a2, axis)));
        float bMin = min(dot(b0, axis), min(dot(b1, axis), dot(b2, axis)));
        float bMax = max(dot(b0, axis), max(dot(b1, axis), dot(b2, axis)));
        float overlap = min(aMax, bMax) - max(aMin, bMin);
        if (overlap <= 0.0) {
            return false;
        }
        if (overlap < minPen) {
            minPen = overlap;
            bestAxis = axis;
        }
    }
    axisOut = bestAxis;
    penOut = minPen;
    return true;
}

int clipPolygonAgainstEdge(vec2 inPts[12], int inCount, vec2 a, vec2 b, float sign, out vec2 outPts[12]) {
    if (inCount == 0) {
        return 0;
    }

    vec2 prev = inPts[inCount - 1];
    float prevSide = cross2d(b - a, prev - a) * sign;
    bool prevInside = prevSide >= 0.0;
    int outCount = 0;

    for (int i = 0; i < inCount; ++i) {
        vec2 curr = inPts[i];
        float currSide = cross2d(b - a, curr - a) * sign;
        bool currInside = currSide >= 0.0;

        if (currInside != prevInside) {
            vec2 dir = curr - prev;
            float denom = cross2d(dir, b - a);
            float t = (abs(denom) > 1e-6) ? (cross2d(a - prev, b - a) / denom) : 0.0;
            t = clamp(t, 0.0, 1.0);
            outPts[outCount++] = prev + dir * t;
        }

        if (currInside) {
            outPts[outCount++] = curr;
        }

        prev = curr;
        prevInside = currInside;
    }

    return outCount;
}

bool intersectionCentroid(vec2 a0, vec2 a1, vec2 a2, vec2 b0, vec2 b1, vec2 b2, out vec2 outCentroid) {
    vec2 polyA[12];
    vec2 polyB[12];
    int countA = 3;
    polyA[0] = a0;
    polyA[1] = a1;
    polyA[2] = a2;

    float orient = cross2d(b1 - b0, b2 - b0);
    float sign = (orient >= 0.0) ? 1.0 : -1.0;
    countA = clipPolygonAgainstEdge(polyA, countA, b0, b1, sign, polyB);
    if (countA == 0) return false;
    countA = clipPolygonAgainstEdge(polyB, countA, b1, b2, sign, polyA);
    if (countA == 0) return false;
    countA = clipPolygonAgainstEdge(polyA, countA, b2, b0, sign, polyB);
    if (countA == 0) return false;

    float area = 0.0;
    vec2 cSum = vec2(0.0);
    for (int i = 0; i < countA; ++i) {
        vec2 p0 = polyB[i];
        vec2 p1 = polyB[(i + 1) % countA];
        float crossVal = cross2d(p0, p1);
        area += crossVal;
        cSum += (p0 + p1) * crossVal;
    }
    if (abs(area) < 1e-6) {
        outCentroid = vec2(0.0);
        for (int i = 0; i < countA; ++i) {
            outCentroid += polyB[i];
        }
        outCentroid /= float(countA);
        return true;
    }
    outCentroid = cSum / (3.0 * area);
    return true;
}

vec3 barycentric(vec2 p, vec2 a, vec2 b, vec2 c) {
    vec2 v0 = b - a;
    vec2 v1 = c - a;
    vec2 v2 = p - a;
    float d00 = dot(v0, v0);
    float d01 = dot(v0, v1);
    float d11 = dot(v1, v1);
    float d20 = dot(v2, v0);
    float d21 = dot(v2, v1);
    float denom = d00 * d11 - d01 * d01;
    if (abs(denom) < 1e-8) {
        return vec3(1.0, 0.0, 0.0);
    }
    float v = (d11 * d20 - d01 * d21) / denom;
    float w = (d00 * d21 - d01 * d20) / denom;
    float u = 1.0 - v - w;
    return vec3(u, v, w);
}

float bodyInvMass(uint bodyIndex) {
    uvec4 data = bodyDataBuffer.bodyData[bodyIndex];
    float sum = 0.0;
    for (uint i = 0u; i < data.y; ++i) {
        sum += nodeInvMassBuffer.nodeInvMasses[data.x + i];
    }
    return sum;
}

void applyImpulse(uint bodyIndex, vec2 impulse, float totalInvMass) {
    uvec4 data = bodyDataBuffer.bodyData[bodyIndex];
    uint offset = data.x;
    for (uint i = 0u; i < data.y; ++i) {
        float invMass = nodeInvMassBuffer.nodeInvMasses[offset + i];
        vec2 v = nodeVelocityBuffer.nodeVelocities[offset + i].xy;
        float weight = (totalInvMass > 0.0) ? (invMass / totalInvMass) : 0.0;
        v += impulse * weight;
        nodeVelocityBuffer.nodeVelocities[offset + i].xy = v;
    }
}

void applyPositionCorrection(uint bodyIndex, vec2 correction, float totalInvMass) {
    uvec4 data = bodyDataBuffer.bodyData[bodyIndex];
    uint offset = data.x;
    for (uint i = 0u; i < data.y; ++i) {
        float invMass = nodeInvMassBuffer.nodeInvMasses[offset + i];
        float weight = (totalInvMass > 0.0) ? (invMass / totalInvMass) : 0.0;
        vec2 p = positionBuffer.positions[offset + i].xy;
        p += correction * weight;
        positionBuffer.positions[offset + i].xy = p;
    }
}

void contactResolve(uint bodyIndex, bool applyVelocity) {
    if (bodyIndex >= pc.bodyCount) {
        return;
    }

    vec2 center = bodyCenter(bodyIndex);
    float radius = bodyRadius(bodyIndex, center);
    int cellRange = int(ceil((radius * 2.0) / CELL_SIZE)) + 1;
    uint cellIndex = spatialHash(center);

    for (int dy = -cellRange; dy <= cellRange; ++dy) {
        for (int dx = -cellRange; dx <= cellRange; ++dx) {
            int cellX = int(cellIndex % GRID_WIDTH) + dx;
            int cellY = int(cellIndex / GRID_WIDTH) + dy;
            cellX = ((cellX % int(GRID_WIDTH)) + int(GRID_WIDTH)) % int(GRID_WIDTH);
            cellY = ((cellY % int(GRID_HEIGHT)) + int(GRID_HEIGHT)) % int(GRID_HEIGHT);
            uint neighborCell = uint(cellX + cellY * int(GRID_WIDTH));

            uint current = spatialMapBuffer.spatialCells[neighborCell].x;
            while (current != NULL_INDEX && current < pc.bodyCount) {
                if (current != bodyIndex && bodyIndex < current) {
                    vec2 otherCenter = bodyCenter(current);
                    float otherRadius = bodyRadius(current, otherCenter);
                    if (distance(center, otherCenter) > radius + otherRadius + CELL_SIZE) {
                        current = spatialNextBuffer.nextIndices[current];
                        continue;
                    }

                    uvec4 aData = bodyDataBuffer.bodyData[bodyIndex];
                    uvec4 bData = bodyDataBuffer.bodyData[current];
                    uint aTriStart = aData.z;
                    uint bTriStart = bData.z;
                    uint aTriCount = aData.w;
                    uint bTriCount = bData.w;

                    for (uint ai = 0u; ai < aTriCount; ++ai) {
                        uvec4 aTri = triangleIndexBuffer.triIndices[aTriStart + ai];
                        vec2 a0 = positionBuffer.positions[aTri.x].xy;
                        vec2 a1 = positionBuffer.positions[aTri.y].xy;
                        vec2 a2 = positionBuffer.positions[aTri.z].xy;

                        for (uint bi = 0u; bi < bTriCount; ++bi) {
                            uvec4 bTri = triangleIndexBuffer.triIndices[bTriStart + bi];
                            vec2 b0 = positionBuffer.positions[bTri.x].xy;
                            vec2 b1 = positionBuffer.positions[bTri.y].xy;
                            vec2 b2 = positionBuffer.positions[bTri.z].xy;

                            vec2 axis;
                            float penetration;
                            if (!triSAT(a0, a1, a2, b0, b1, b2, axis, penetration)) {
                                continue;
                            }

                            vec2 centers = (a0 + a1 + a2) / 3.0 - (b0 + b1 + b2) / 3.0;
                            if (dot(axis, centers) < 0.0) {
                                axis = -axis;
                            }

                            vec2 contactPoint;
                            if (!intersectionCentroid(a0, a1, a2, b0, b1, b2, contactPoint)) {
                                contactPoint = (a0 + a1 + a2 + b0 + b1 + b2) / 6.0;
                            }

                            vec3 wA = barycentric(contactPoint, a0, a1, a2);
                            vec3 wB = barycentric(contactPoint, b0, b1, b2);

                            float invA0 = nodeInvMassBuffer.nodeInvMasses[aTri.x];
                            float invA1 = nodeInvMassBuffer.nodeInvMasses[aTri.y];
                            float invA2 = nodeInvMassBuffer.nodeInvMasses[aTri.z];
                            float invB0 = nodeInvMassBuffer.nodeInvMasses[bTri.x];
                            float invB1 = nodeInvMassBuffer.nodeInvMasses[bTri.y];
                            float invB2 = nodeInvMassBuffer.nodeInvMasses[bTri.z];

                            float wSumA = invA0 * wA.x * wA.x + invA1 * wA.y * wA.y + invA2 * wA.z * wA.z;
                            float wSumB = invB0 * wB.x * wB.x + invB1 * wB.y * wB.y + invB2 * wB.z * wB.z;
                            float wSum = max(wSumA + wSumB, 1e-6);

                            float pen = max(penetration - CONTACT_SLOP, 0.0);
                            if (pen > 0.0 && !applyVelocity) {
                                float lambda = pen / wSum;
                                vec2 deltaA = axis * lambda;
                                vec2 deltaB = -axis * lambda;

                                positionBuffer.positions[aTri.x].xy += deltaA * (invA0 * wA.x);
                                positionBuffer.positions[aTri.y].xy += deltaA * (invA1 * wA.y);
                                positionBuffer.positions[aTri.z].xy += deltaA * (invA2 * wA.z);

                                positionBuffer.positions[bTri.x].xy += deltaB * (invB0 * wB.x);
                                positionBuffer.positions[bTri.y].xy += deltaB * (invB1 * wB.y);
                                positionBuffer.positions[bTri.z].xy += deltaB * (invB2 * wB.z);
                            }

                            if (applyVelocity) {
                                vec2 vA = nodeVelocityBuffer.nodeVelocities[aTri.x].xy * wA.x +
                                          nodeVelocityBuffer.nodeVelocities[aTri.y].xy * wA.y +
                                          nodeVelocityBuffer.nodeVelocities[aTri.z].xy * wA.z;
                                vec2 vB = nodeVelocityBuffer.nodeVelocities[bTri.x].xy * wB.x +
                                          nodeVelocityBuffer.nodeVelocities[bTri.y].xy * wB.y +
                                          nodeVelocityBuffer.nodeVelocities[bTri.z].xy * wB.z;

                                vec2 relVel = vA - vB;
                                float velAlongNormal = dot(relVel, axis);
                                float bias = BAUMGARTE_BETA * pen / max(pc.deltaTime, 0.0001);

                                vec4 paramsA = bodyParamsBuffer.bodyParams[bodyIndex];
                                vec4 paramsB = bodyParamsBuffer.bodyParams[current];
                                float restitution = min(paramsA.z, paramsB.z);
                                float friction = min(paramsA.w, paramsB.w);

                                if (velAlongNormal < bias) {
                                    float j = -(1.0 + restitution) * (velAlongNormal - bias);
                                    float impulseMag = j / wSum;
                                    vec2 impulse = impulseMag * axis;

                                    nodeVelocityBuffer.nodeVelocities[aTri.x].xy += impulse * (invA0 * wA.x);
                                    nodeVelocityBuffer.nodeVelocities[aTri.y].xy += impulse * (invA1 * wA.y);
                                    nodeVelocityBuffer.nodeVelocities[aTri.z].xy += impulse * (invA2 * wA.z);

                                    nodeVelocityBuffer.nodeVelocities[bTri.x].xy -= impulse * (invB0 * wB.x);
                                    nodeVelocityBuffer.nodeVelocities[bTri.y].xy -= impulse * (invB1 * wB.y);
                                    nodeVelocityBuffer.nodeVelocities[bTri.z].xy -= impulse * (invB2 * wB.z);

                                    vec2 tangent = relVel - velAlongNormal * axis;
                                    float tangentLen = length(tangent);
                                    if (tangentLen > 1e-4) {
                                        vec2 tDir = tangent / tangentLen;
                                        float jt = -dot(relVel, tDir);
                                        float maxFriction = friction * impulseMag;
                                        jt = clamp(jt, -maxFriction, maxFriction);
                                        vec2 tImpulse = jt * tDir;

                                        nodeVelocityBuffer.nodeVelocities[aTri.x].xy += tImpulse * (invA0 * wA.x);
                                        nodeVelocityBuffer.nodeVelocities[aTri.y].xy += tImpulse * (invA1 * wA.y);
                                        nodeVelocityBuffer.nodeVelocities[aTri.z].xy += tImpulse * (invA2 * wA.z);

                                        nodeVelocityBuffer.nodeVelocities[bTri.x].xy -= tImpulse * (invB0 * wB.x);
                                        nodeVelocityBuffer.nodeVelocities[bTri.y].xy -= tImpulse * (invB1 * wB.y);
                                        nodeVelocityBuffer.nodeVelocities[bTri.z].xy -= tImpulse * (invB2 * wB.z);
                                    }
                                }
                            }
                        }
                    }
                }
                current = spatialNextBuffer.nextIndices[current];
            }
        }
    }
}

void globalStep(uint nodeIndex) {
    if (nodeIndex >= pc.nodeCount) {
        return;
    }

    vec2 predicted = positionBuffer.positions[nodeIndex].xy;
    vec4 goal = nodeForceBuffer.nodeForces[nodeIndex];
    float stiffness = goal.z;
    float invMass = nodeInvMassBuffer.nodeInvMasses[nodeIndex];
    float mass = (invMass > 0.0) ? (1.0 / invMass) : 0.0;
    if (stiffness > 0.0) {
        uint bodyIndex = nodeIndex / NODES_PER_BODY;
        vec4 params = bodyParamsBuffer.bodyParams[bodyIndex];
        float compliance = params.y;
        float dt = max(pc.deltaTime, 0.0001);
        float complianceTerm = compliance / (dt * dt);
        float effectiveStiffness = stiffness / (1.0 + complianceTerm * stiffness);
        vec2 goalPos = goal.xy * (effectiveStiffness / stiffness);
        vec2 newPos = (mass * predicted + goalPos) / (mass + effectiveStiffness);
        positionBuffer.positions[nodeIndex].xy = newPos;
    }
}

void updateVelocity(uint nodeIndex) {
    if (nodeIndex >= pc.nodeCount) {
        return;
    }

    vec2 pos = positionBuffer.positions[nodeIndex].xy;
    vec2 prev = currentPositionBuffer.currentPositions[nodeIndex].xy;
    vec2 vel = (pos - prev) / max(pc.deltaTime, 0.0001);
    nodeVelocityBuffer.nodeVelocities[nodeIndex].xy = vel;
    currentPositionBuffer.currentPositions[nodeIndex] = vec4(pos, 0.0, 1.0);
}

void main() {
    uint index = gl_GlobalInvocationID.x + pc.elementOffset;

    if (pc.mode == MODE_CLEAR_FORCES) {
        if (index < pc.nodeCount) {
            clearGoals(index);
        }
        return;
    }

    if (pc.mode == MODE_PREDICT) {
        if (index < pc.nodeCount) {
            predictPosition(index);
        }
        return;
    }

    if (pc.mode == MODE_LOCAL) {
        if (index < pc.triangleCount) {
            computeGoals(index);
        }
        return;
    }

    if (pc.mode == MODE_GLOBAL) {
        if (index < pc.nodeCount) {
            globalStep(index);
        }
        return;
    }

    if (pc.mode == MODE_CLEAR_SPATIAL) {
        if (index < SPATIAL_MAP_SIZE) {
            clearSpatial(index);
        }
        return;
    }

    if (pc.mode == MODE_BUILD_SPATIAL) {
        if (index < pc.bodyCount) {
            buildSpatial(index, bodyCenter(index));
        }
        return;
    }

    if (pc.mode == MODE_CONTACT_CONSTRAINTS) {
        if (index < pc.bodyCount) {
            contactResolve(index, false);
        }
        return;
    }

    if (pc.mode == MODE_CONTACT_VELOCITY) {
        if (index < pc.bodyCount) {
            contactResolve(index, true);
        }
        return;
    }

    if (pc.mode == MODE_UPDATE_VELOCITY) {
        if (index < pc.nodeCount) {
            updateVelocity(index);
        }
    }
}
