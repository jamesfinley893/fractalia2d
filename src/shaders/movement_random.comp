#version 450

// Optimized workgroup size for maximum GPU occupancy
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Push constants for timing and control
layout(push_constant) uniform ComputePushConstants {
    float time;
    float deltaTime;
    uint entityCount;
    uint frame;
    uint entityOffset;  // For chunked dispatches
} pc;

// SoA (Structure of Arrays) buffers for better cache locality and vectorization
layout(std430, binding = 0) buffer VelocityBuffer {
    vec4 velocities[];
} velocityBuffer;

layout(std430, binding = 1) buffer MovementParamsBuffer {
    vec4 movementParams[];
} movementParamsBuffer;

layout(std430, binding = 2) buffer RuntimeStateBuffer {
    vec4 runtimeStates[];
} runtimeStateBuffer;

layout(std430, binding = 8) buffer ControlParamsBuffer {
    vec4 controlParams[];  // desiredVel.xy, controlFlag, renderScale
} controlParamsBuffer;

// Position buffers are not used by movement shader - only physics shader uses them
// This shader only updates velocity every 900 frames

/* ---------- Optimized Random Walk Movement Functions ---------- */

// Constants for improved performance
const float TWO_PI = 6.28318530718;
const uint CYCLE_LENGTH = 120u; // More frequent movement updates for dynamic behavior (2 seconds at 60fps)
const float INV_4294967295 = 2.3283064e-10; // 1.0 / 4294967295.0

// Optimized Wang hash - fewer operations
uint fastHash(uint seed) {
    seed ^= seed >> 16u;
    seed *= 0x7feb352du;
    seed ^= seed >> 15u;
    seed *= 0x846ca68bu;
    seed ^= seed >> 16u;
    return seed;
}

// Fast hash to float conversion
float hashToFloat(uint hash) {
    return float(hash) * INV_4294967295;
}

// Pre-computed sine/cosine lookup tables (shared memory)
shared float sinLookup[64];
shared float cosLookup[64];

// Fast trigonometric approximation using lookup table
void initTrigTables() {
    uint tid = gl_LocalInvocationID.x;
    float angle = float(tid) * (TWO_PI / 64.0);
    sinLookup[tid] = sin(angle);
    cosLookup[tid] = cos(angle);
}

vec2 fastSinCos(float angle) {
    // Normalize angle to [0, TWO_PI]
    angle = mod(angle, TWO_PI);
    
    // Map to lookup table index
    float indexFloat = angle * (64.0 / TWO_PI);
    uint index0 = uint(indexFloat) & 63u;
    uint index1 = (index0 + 1u) & 63u;
    
    // Linear interpolation
    float t = fract(indexFloat);
    float sinVal = mix(sinLookup[index0], sinLookup[index1], t);
    float cosVal = mix(cosLookup[index0], cosLookup[index1], t);
    
    return vec2(sinVal, cosVal);
}

void main() {
    // Initialize shared trigonometric lookup tables once per workgroup
    initTrigTables();
    barrier(); // Wait for lookup table initialization
    
    // Get current entity index with chunk offset
    uint entityIndex = gl_GlobalInvocationID.x + pc.entityOffset;
    
    // Early exit for out-of-bounds entities
    if (entityIndex >= pc.entityCount) {
        return;
    }
    
    // Load entity data from SoA buffers - much better cache locality
    vec4 velocity = velocityBuffer.velocities[entityIndex];
    
    vec4 controlParams = controlParamsBuffer.controlParams[entityIndex];

    // Skip GPU-driven random walk for manually controlled entities
    if (controlParams.z > 0.5) {
        return;
    }
    vec4 movementParams = movementParamsBuffer.movementParams[entityIndex];
    vec4 runtimeState = runtimeStateBuffer.runtimeStates[entityIndex];
    
    // Extract movement parameters
    float amplitude = movementParams.x;
    float phase = movementParams.z;
    float initialized = runtimeState.w; // initialized flag is in .w
    
    // Mark entity as initialized if not already
    if (initialized < 0.5) {
        runtimeStateBuffer.runtimeStates[entityIndex].w = 1.0; // Mark as initialized
    }
    
    // Calculate cycle using frame number and entity offset for staggering
    float cycle = mod(float(pc.frame + entityIndex * 37u), float(CYCLE_LENGTH));
    
    // Generate new velocity direction every 120 frames (cycle reset) OR on initialization
    if (cycle < 1.0 || initialized < 0.5) {
        // TRULY RANDOM: Use entity index and frame for random seed
        uint seed = entityIndex * 1664525u + pc.frame * 1013904223u;
        uint hash = fastHash(seed);
        float randAngle = hashToFloat(hash) * TWO_PI;
        
        // Enhanced speed with moderate variance for frequent updates
        uint speedHash = fastHash(seed + 12345u);
        float speedMultiplier = 1.0 + hashToFloat(speedHash) * 2.0; // Range: 1.0 to 3.0
        float speed = 1.2 * speedMultiplier; // Base speed 1.2, final range: 1.2 to 3.6
        
        // Add moderate angular momentum for dynamic movement
        uint spiralHash = fastHash(seed + 67890u);
        float angularVelocity = (hashToFloat(spiralHash) - 0.5) * 0.15; // -0.075 to +0.075 rad/frame
        
        // Use basic trig for random direction with enhanced velocity
        velocity.x = speed * cos(randAngle + angularVelocity);
        velocity.y = speed * sin(randAngle + angularVelocity);
        
        // Write updated velocity back to SoA buffer
        velocityBuffer.velocities[entityIndex] = velocity;
    }
}
